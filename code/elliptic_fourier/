#include <cairomm/context.h>
#include <cmath>
#include <numbers>
#include <algorithm>
#include "graph_area.h"

using std::sin;
using std::cos;
using std::min;
using std::max;
using std::numbers::pi;

GraphArea::GraphArea()
{
	set_draw_func(sigc::mem_fun(*this, &GraphArea::draw));
}

GraphArea::~GraphArea()
{
}

// This is a method of an area and the only information
// we have about said area is it's width and height
void GraphArea::draw(
	const Cairo::RefPtr<Cairo::Context>& cr,
	const int width,
	const int height
) {
	cr->set_source_rgb(0, 0, 0.5); // blue

	int i = 0;
	cr->move_to(i, height/2 + waveform(i/20.0) * height/4);
	for(i = 1; i <= width; i++)
	{
		cr->line_to(i, height/2 + waveform(i/20.0) * height/4);
	}
	//cr->fill();

	cr->begin_new_path();
	cr->set_source_rgb(0, 0, 0); // black
	double theta = 0;
	double main_radius = min(width, height) / 2;
	double radius;
	radius = main_radius/2 + (main_radius/2) * waveform(theta);
	cr->move_to(width/2 + radius*sin(theta), height/2 + radius*cos(theta));
	for(;theta <= 2 * pi; theta += 0.01)
	{
		radius = main_radius/2 + (main_radius/2) * waveform(theta);
		cr->line_to(width/2 + radius*sin(theta), height/2 + radius*cos(theta));
	}
	cr->fill();
}

// This is a waveform method that we can use generally to return a value based on an input
double GraphArea::waveform(double x)
{
	double y = 0;
	double freqs[] = {10, 4};
	double mags[] = {0.1, 0.14};

	for(int i = 0; i < sizeof(freqs)/sizeof(freqs[0]); i++)
	{
		y += sin(x * freqs[i]) * mags[i];
	}

	return y;
}

double coefficient(
	int32_t n,
	double T,
	int32_t K,
	double[] xy,
	double[] t,
	double[] delta_xy,
	double[] delta_t,
	double (*trig_function)(double)
) {
	double sum = 0;
	for(int32_t p = 0; p < K; p++)
	{
		p_minus_one = p == 0 ? K - 1 : p - 1;
		sum += (delta_xy / delta_t) * (trig_function((2 * n * pi * t[p]) - trig_function(2 * n * pi * t[p_minus_one])));
	}
	sum *= T / (2 * n * n * pi * pi);
	return sum;
}

double centre(
	double T,
	int32_t K,
	double[] xy,
	double[] t,
	double[] delta_xy,
	double[] delta_t
) {
	double sum = 0;
	for(int32_t p = 0; p < K; p++)
	{
		sum += (delta_xy[p] / (2 * delta_t[p]));
		for(int32_t j = 0; j < p; j++)
		{
			sum += delta_xy[j];
			sum -= (delta_xy[p] / delta_t[p]) * delta_t[j];
		}
	}
}
